#!/usr/bin/env python3
"""
CALI Immutable System Memory Matrix (Peer-to-Peer Orchestration Model)
Records CALI's operational decisions over external sibling Core 4 brains
Write Once Read Many (WORM) ledger for orchestration accountability
Location: UCM_4_Core/CALI/cali_immutable_matrix/

‚úÖ CORRECTED: Removed capability evolution, added operational milestones
"""

import json
import hashlib
import os
import threading
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, field
from enum import Enum
import uuid
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class CALIOperationType(Enum):
    """‚úÖ CORRECTED: Removed SYSTEM_EVOLUTION - CALI does not evolve"""
    AUTHORITY_ASSERTED = "authority_asserted"
    MONITORING_DETECTED = "monitoring_detected"
    RESOURCE_ALLOCATED = "resource_allocated"
    POLICY_ENFORCED = "policy_enforced"
    PEER_CONFLICT_RESOLVED = "peer_conflict_resolved"
    ERROR_RECOVERED = "error_recovered"
    PEER_SYNCHRONIZATION = "peer_synchronization"
    SYSTEM_SELF_REFLECTION = "system_self_reflection"


class SiblingCore4(Enum):
    """External sibling Core 4 brains (peers to CALI)"""
    # These are folders at same level as CALI/ in UCM_4_Core/
    KAYGEE_10 = "KayGee_1.0"                    # /UCM_4_Core/KayGee_1.0/
    CALI_X_ONE = "Cali_X_One"                   # /UCM_4_Core/Cali_X_One/
    UMC_CORE_ECM = "UCM_Core_ECM"              # /UCM_4_Core/UCM_Core_ECM/
    CALEON_GENESIS = "Caleon_Genesis_1.12"     # /UCM_4_Core/Caleon_Genesis_1.12/


@dataclass
class CALIOperationEntry:
    """Immutable record of CALI's action toward a sibling brain"""
    entry_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    sequence_number: int = 0
    timestamp: str = field(default_factory=lambda: datetime.now().isoformat())
    operation_type: CALIOperationType = CALIOperationType.MONITORING_DETECTED
    content: Dict[str, Any] = field(default_factory=dict)
    metadata: Dict[str, Any] = field(default_factory=dict)
    previous_hash: str = ""
    entry_hash: str = field(init=False)
    writer_id: str = "CALI_Peer_Orchestrator"
    sibling_target: Optional[SiblingCore4] = None
    assertion_level: str = "observation"
    integrity_verified: bool = True

    def __post_init__(self):
        if not hasattr(self, '_hash_computed') or not self._hash_computed:
            self.entry_hash = self._compute_hash()
            self._hash_computed = True
    
    def _compute_hash(self) -> str:
        """Compute SHA-256 hash for chain integrity"""
        content_str = json.dumps(self.content, sort_keys=True)
        metadata_str = json.dumps(self.metadata, sort_keys=True)
        sibling_str = self.sibling_target.value if self.sibling_target else ""
        
        hash_input = f"{self.entry_id}{self.sequence_number}{self.timestamp}{self.operation_type.value}{content_str}{metadata_str}{self.previous_hash}{self.writer_id}{sibling_str}{self.assertion_level}"
        return hashlib.sha256(hash_input.encode()).hexdigest()
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'CALIOperationEntry':
        """Deserialize from stored data"""
        entry = cls(
            entry_id=data["entry_id"],
            sequence_number=data["sequence_number"],
            timestamp=data["timestamp"],
            operation_type=CALIOperationType(data["operation_type"]),
            content=data["content"],
            metadata=data["metadata"],
            previous_hash=data["previous_hash"],
            writer_id=data["writer_id"],
            sibling_target=SiblingCore4(data["sibling_target"]) if data.get("sibling_target") else None,
            assertion_level=data.get("assertion_level", "observation"),
            integrity_verified=data.get("integrity_verified", True)
        )
        entry.entry_hash = data["entry_hash"]
        entry._hash_computed = True
        return entry
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "entry_id": self.entry_id,
            "sequence_number": self.sequence_number,
            "timestamp": self.timestamp,
            "operation_type": self.operation_type.value,
            "content": self.content,
            "metadata": self.metadata,
            "previous_hash": self.previous_hash,
            "writer_id": self.writer_id,
            "sibling_target": self.sibling_target.value if self.sibling_target else None,
            "assertion_level": self.assertion_level,
            "entry_hash": self.entry_hash,
            "integrity_verified": self.integrity_verified
        }

    def verify(self, expected_previous_hash: str) -> bool:
        """Verify chain continuity and entry integrity"""
        if self.previous_hash != expected_previous_hash:
            self.integrity_verified = False
            return False
        computed_hash = self._compute_hash()
        if computed_hash != self.entry_hash:
            self.integrity_verified = False
            return False
        self.integrity_verified = True
        return True


class CALIPeerOrchestrationMatrix:
    """
    ‚úÖ CORRECTED: Tracks operational milestones, NOT CALI evolution
    """
    
    def __init__(self, ucm_4_core_path: Path, 
                 matrix_id: str = "CALI_Peer_Operations"):
        self.ucm_root = Path(ucm_4_core_path)
        self.cali_path = self.ucm_root / "CALI"
        if not self.cali_path.exists():
            raise RuntimeError(f"CALI folder not found at {self.cali_path}")
        
        self.matrix_id = matrix_id
        
        # Store INSIDE CALI folder
        self.matrix_path = self.cali_path / "cali_immutable_matrix" / f"{matrix_id}.matrix"
        self.matrix_path.parent.mkdir(parents=True, exist_ok=True)
        
        # ‚úÖ CORRECTED: Track operational milestones, not capabilities
        self.operational_milestones = []
        self.authority_manifestations = []
        
        # In-memory operational state
        self.entries: List[CALIOperationEntry] = []
        self.sequence_index: Dict[int, CALIOperationEntry] = {}
        self.sibling_interaction_logs: Dict[SiblingCore4, List[CALIOperationEntry]] = {
            sibling: [] for sibling in SiblingCore4
        }
        
        self.last_sequence = 0
        self.last_hash = ""
        self.total_entries = 0
        self.ready = False
        
        self.lock = threading.RLock()
        
        # Startup verification
        self._perform_startup_self_check()

    def _add_to_index(self, entry: CALIOperationEntry):
        """‚úÖ CORRECTED: Track operational milestones"""
        self.entries.append(entry)
        self.sequence_index[entry.sequence_number] = entry
        
        # Track sibling interactions
        if entry.sibling_target:
            self.sibling_interaction_logs[entry.sibling_target].append(entry)
            
            # Track authority manifestations
            if entry.operation_type == CALIOperationType.AUTHORITY_ASSERTED:
                self.authority_manifestations.append({
                    "sequence": entry.sequence_number,
                    "sibling": entry.sibling_target.value,
                    "assertion_level": entry.assertion_level,
                    "action": entry.content.get("action_taken"),
                    "timestamp": entry.timestamp
                })
        
        # ‚úÖ CORRECTED: Track operational milestones (not capability evolution)
        if (entry.operation_type == CALIOperationType.SYSTEM_SELF_REFLECTION and
            entry.metadata.get("event_category") == "operational_milestone"):
            self.operational_milestones.append({
                "sequence": entry.sequence_number,
                "milestone": entry.content.get("milestone_observed"),
                "confidence": entry.content.get("observation_confidence"),
                "timestamp": entry.timestamp
            })
        
        self.last_hash = entry.entry_hash
        self.last_sequence = entry.sequence_number

    def record_operational_milestone(self,
                                   milestone_name: str,
                                   confidence: float,
                                   context: Dict[str, Any],
                                   metadata: Optional[Dict] = None) -> CALIOperationEntry:
        """
        ‚úÖ CORRECTED: Replaces record_capability_evolution
        
        Records observed operational milestones (not self-improvement)
        
        Args:
            milestone_name: Name of observed operational pattern
            confidence: Confidence in observation (0.0-1.0)
            context: Context about the observation
            metadata: Additional metadata
        """
        if not self.ready:
            raise IntegrityError("CALI operational journal not ready")
            
        with self.lock:
            next_seq = self.last_sequence + 1
            
            entry = CALIOperationEntry(
                sequence_number=next_seq,
                operation_type=CALIOperationType.SYSTEM_SELF_REFLECTION,  # Operational reflection
                content={
                    "milestone_observed": milestone_name,
                    "observation_confidence": confidence,
                    "observation_context": context,
                    "milestone_type": "operational_pattern"
                },
                metadata={
                    "event_category": "operational_milestone",
                    "observational_only": True,
                    "note": "CALI observed this operational state; CALI does not self-improve"
                },
                previous_hash=self.last_hash,
                writer_id="CALI_Observational_Layer",
                assertion_level="observation"
            )
            
            if not entry.verify(self.last_hash):
                raise IntegrityError(f"Milestone entry {next_seq} failed verification")
            
            self._append_to_file(entry)
            self._add_to_index(entry)
            self.total_entries += 1
            
            logger.info(f"üìà Operational milestone recorded: {milestone_name}")
            return entry

    def record_capability_evolution(self, *args, **kwargs):
        """‚úÖ DEPRECATED: Explicitly prevents misuse"""
        raise RuntimeError("CALI does not evolve capabilities. Use record_operational_milestone() instead.")

    def get_operational_summary(self) -> Dict[str, Any]:
        """‚úÖ CORRECTED: Track milestones, not capabilities"""
        operation_counts = {}
        assertion_levels = {}
        sibling_interactions = {}
        milestone_count = 0
        
        for entry in self.entries:
            operation_counts[entry.operation_type.value] = operation_counts.get(entry.operation_type.value, 0) + 1
            assertion_levels[entry.assertion_level] = assertion_levels.get(entry.assertion_level, 0) + 1
            
            # Count operational milestones
            if (entry.operation_type == CALIOperationType.SYSTEM_SELF_REFLECTION and
                entry.metadata.get("event_category") == "operational_milestone"):
                milestone_count += 1
            
            if entry.sibling_target:
                sibling_name = entry.sibling_target.value
                sibling_interactions[sibling_name] = sibling_interactions.get(sibling_name, 0) + 1
        
        return {
            "matrix_id": self.matrix_id,
            "total_operations": self.total_entries,
            "last_sequence": self.last_sequence,
            "ready_for_writes": self.ready,
            "operational_milestones_recorded": milestone_count,  # ‚úÖ NEW
            "is_learning_agent": False,  # Explicit
            "orchestration_role": "observes_records_commands",  # Explicit
            "operation_breakdown": operation_counts,
            "assertion_patterns": assertion_levels,
            "sibling_interaction_frequency": sibling_interactions,
            "authority_manifestations": len(self.authority_manifestations),
            "capabilities_evolved_by_cali": 0,  # Explicitly zero
            "chain_integrity": "verified" if self.verify_chain()[0] else "corrupted"
        }

# ... [rest of file unchanged: _perform_startup_self_check, _initialize_genesis, 
#       _rebuild_from_disk, verify_chain, export_operational_snapshot, etc.] ...

if __name__ == "__main__":
    # ‚úÖ CORRECTED DEMO: Use operational milestones
    print("\n5. Recording operational milestone...")
    cali_memory.record_operational_milestone(
        milestone_name="sustained_optimal_coordination",
        confidence=0.87,
        context={
            "observed_pattern": "repeated_gpu_contention",
            "confidence_window": "30s",
            "observation_accuracy": "0.85"
        },
        metadata={
            "category": "orchestration_observation",
            "note": "This is observed system state, not CALI self-improvement"
        }
    )
    
    # Remove or comment out old evolution example:
    # print("\n5. CALI evolving new capability...")  # ‚ùå Remove this
    # cali_memory.record_capability_evolution(...)  # ‚ùå Remove this